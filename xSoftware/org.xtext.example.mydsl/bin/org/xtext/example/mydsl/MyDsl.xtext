// automatically generated by Xtext
grammar org.xtext.example.mydsl.MyDsl with org.eclipse.xtext.common.Terminals

import "http://www.uniandes.edu.co/xsoftware" 
import "http://www.eclipse.org/emf/2002/Ecore" as ecore



Api returns Api:
	{Api}
	'apiURL' EQUAL (url=EString) SEMICOLON
		entidades+=Entidad*
		primitivetypes+=PrimitiveType*
		serviciosRest+=ServicioRest*
		tests+=Test*;

Entidad returns Entidad:
	SimpleEntity | MockarooEntity;
	
SimpleEntity returns SimpleEntity:
	'SimpleEntity' (name=ID) '{'
		atributos+=(AtributoSimple)*
	'}';
	
Atributo returns Atributo:
	AtributoMocka | AtributoArreglo | AtributoSimple;
	
AtributoMocka returns AtributoMocka:
	(tipo=TipoAtributo) (name=ID) ('(' ((primaryKey?='PK,mockType' EQUAL (mockType=Mockaroo))|('mockType' EQUAL (mockType=Mockaroo))) ')') SEMICOLON;
	
AtributoArreglo returns AtributoArreglo:
	(tipo=TipoAtributo)'[' ']' (name=ID) SEMICOLON;
	
AtributoSimple returns AtributoSimple:
	(tipo=TipoAtributo) (name=ID) SEMICOLON;
	
	
MyString returns MyString:
	name=EString;
	
MyNumeric returns MyNumeric:
	name=EInt;
	
MyBoolean returns MyBoolean:
	name=EBoolean;	

MockarooEntity returns MockarooEntity:
	'Entity' name=ID '{'
		atributos+=(Atributo)*
	'}';

ServicioRest returns ServicioRest:
	(metodo=TipoMetodoRest) (name=EString) '{'
	
		'URL' EQUAL (url=Url)SEMICOLON
		
		(request=Request)?
		
		response=Response
	'}';
	
Url returns Url:
	{Url}
	urlexpresions+=(UrlExpresion)+;
	
UrlExpresion returns UrlExpresion:
	(StringType | Parametro);
	
StringType returns StringType:
	{StringType}
	'/'text=EString;
	
Parametro returns Parametro:
	(QueryParam | PathParam );
	
QueryParam returns QueryParam:
	'?'?"${" name=ID "}";	
	
PathParam returns PathParam:
	"/:{" name=ID "}";

Response returns Response:
	'Response'
	'{'
		'Type' EQUAL ((tipoEntidad=[Entidad])|(tipoPrimitivo=TipoAtributo)) ('[' ']')? SEMICOLON
	'}';
	
Request returns Request:
	'Request'
	'{'
		'Type' EQUAL ((tipoEntidad=[Entidad])|(tipoPrimitivo=TipoAtributo)) ('[' ']')? SEMICOLON
	'}';

	
TipoEntidad returns Entidad:
	(MockarooEntity | SimpleEntity);
	
PrimitiveType returns PrimitiveType:
	name=TipoAtributo;
	
DatoPrimitivo returns DatoPrimitivo:
	MyNumeric | MyString | MyBoolean;

Test returns Test:
	{Test}
	'Test' ID '{'
		'service' EQUAL service=[ServicioRest] SEMICOLON
		'description' EQUAL  descripcion=EString   SEMICOLON
		('Mapping' '['
			mappings+=Mapping*
		']')?
		'Assertions' '{'
			asertions+=Asercion*
		'}'
	'}';
//Este codigo es para hacer la referencia cruzada y que se vea reflejada en el modelo, sin embargo sin scoping no fue posible hacer que la gramatica compilara bien las referencias
//Como el enfique de esta entrega es la gramatica se opto por usar un QualifiedName que no hace l referencia pero parsea bien la gramatica
/**
Mapping returns Mapping:
	'{parameter' EQUAL servicio=[ServicioRest] parametro=[Parametro] ',' 'value' EQUAL (('request->'referenciaEntidad=[Entidad] '.'referencia=[Atributo])|datoprimitivo=(DatoPrimitivo)) '}';
*/
Mapping returns Mapping:
	'{parameter' EQUAL  parametro=[Parametro | QualifiedName] ',' 'value' EQUAL ( 'request->' atributo=[Atributo | QualifiedName]| datoprimitivo=(DatoPrimitivo)) '}';

//Este codigo es para hacer la referencia cruzada y que se vea reflejada en el modelo, sin embargo sin scoping no fue posible hacer que la gramatica compilara bien las referencias
//Como el enfique de esta entrega es la gramatica se opto por usar un QualifiedName que no hace l referencia pero parsea bien la gramatica
/**
Asercion returns Asercion:
	('response.status'|'response'|'response->'entidad=[Entidad]'.'atributo=[Atributo]) operador=Operador (elementoPrimitivo2=DatoPrimitivo|'parameter.'servicio=[ServicioRest] '.' parametro=[Parametro]) SEMICOLON;		
*/
Asercion returns Asercion:
	(elemento1=ElementoStatus |elemento1=ElementoResponse |'response->' elemento1=ElementoAtributo ) operador=Operador (elemento2=ElementoPrimitivo|'parameter.'elemento2=ElementoParametro ) SEMICOLON;

ElementoStatus returns ElementoAsersion:
	tipo='response.status';
	
ElementoResponse returns ElementoAsersion:
	tipo='response';
	
ElementoAtributo returns ElementoAsersion:
	atributo=[Atributo | QualifiedName];
	
ElementoParametro returns ElementoAsersion:
	parametro=[Parametro | QualifiedName];
	
ElementoPrimitivo returns ElementoAsersion:
	elementoPrimitivo=DatoPrimitivo;

EBoolean returns ecore::EBoolean:
	'true' | 'false';
	
EDouble returns ecore::EDouble:
	'-'? INT? '.' INT (('E'|'e') '-'? INT)?;

EInt returns ecore::EInt: 
	INT;
	
EString returns ecore::EString:
	STRING | ID;
	
QualifiedName:
 ID('.' ID)*;

enum TipoAtributo returns TipoAtributo:
	string = 'string' | int = 'int' | boolean = 'boolean';
	
enum Operador returns Operador:
	Igual = '==' | Mayor = '>' | Menor = '<' | MayorIgual = '>=' | MenorIgual = '<=';

enum Mockaroo returns Mockaroo:
				FirstNameType = 'FirstNameType' | LastNameType = 'LastNameType' | FamilyNameType = 'FamilyNameType' | FullNameType = 'FullNameType' | GenderType = 'GenderType' | EmailAddressType = 'EmailAddressType' | PhoneType = 'PhoneType' | CountryType = 'CountryType' | CityType = 'CityType' | CountryCodeType = 'CountryCodeType' | LatitudeType = 'LatitudeType' | LongitudeType = 'LongitudeType' | RowNumberType = 'RowNumberType' | BooleanType = 'BooleanType';

enum TipoMetodoRest returns TipoMetodoRest:
				GET = 'GET' | POST = 'POST' | PUT = 'PUT' | DELETE = 'DELETE';	

terminal EQUAL : "=";
terminal SEMICOLON : ";";
